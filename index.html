<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Due Chat con Ruoli Invertiti nella Seconda (Un Messaggio per Turno)</title>
    
    <style>
        /* Impostazioni globali */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            -webkit-font-smoothing: antialiased; 
            text-rendering: optimizeLegibility;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #ffffff; 
            display: flex;
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            width: 100vw; 
            overflow-x: auto; 
            position: relative; 
        }

        /* Contenitore Principale per le Due Chat (Desktop/Affiancate) */
        #main-container {
            display: flex;
            gap: 40px; /* Spazio tra le due chat */
            padding: 20px;
            height: 100vh; 
            width: 100%; /* Lasciamo che il contenitore principale occupi tutta la larghezza */
            align-items: center;
            justify-content: center; 
            box-sizing: border-box;
        }

        /* Lo schermo centrato (responsive) */
        .chat-container {
            flex: 1; /* Permette alle chat di crescere e occupare lo spazio disponibile */
            max-width: 400px; /* Impostiamo un limite massimo più stretto */
            height: 100%; 
            
            background-color: #ffffff;
            display: flex;
            flex-direction: column;
            overflow: hidden; 
            border: none; 
            box-shadow: none; 
        }
        
        /* Finestra dove appaiono i messaggi (Scorrimento Manuale) */
        .chat-window {
            flex-grow: 1; 
            padding: 20px 10px;
            overflow-y: auto; 
            display: flex;
            flex-direction: column;
            gap: 10px; 
            -webkit-overflow-scrolling: touch; 
        }

        /* Stile generico per una bolla di messaggio */
        .message {
            padding: 12px 18px;
            line-height: 1.4;
            max-width: 75%;
            word-wrap: break-word;
            opacity: 0;
            transform: scale(0.9);
            animation: pop-in 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            position: relative; 
        }

        /* Stili Base per Chat 1 */
        
        /* Forme delle bolle iMessage (Destinatario) -> Griga a Sinistra */
        .message.recipient-default {
            align-self: flex-start;
            background-color: #e5e5ea;
            color: #000000;
            border-top-left-radius: 18px;
            border-top-right-radius: 18px;
            border-bottom-right-radius: 18px;
            border-bottom-left-radius: 4px; 
        }

        /* Forme delle bolle iMessage (Mittente) -> Blu a Destra */
        .message.sender-default {
            align-self: flex-end;
            background-color: #007aff;
            color: #ffffff;
            border-top-left-radius: 18px;
            border-top-right-radius: 18px;
            border-bottom-left-radius: 18px;
            border-bottom-right-radius: 4px; 
        }
        
        /* Stili INVERTITI per Chat 2 */
        
        /* Forme delle bolle iMessage (Destinatario) -> Blu a Destra */
        #chat-window-2 .message.recipient-inverted {
            align-self: flex-end;
            background-color: #007aff;
            color: #ffffff;
            border-top-left-radius: 18px;
            border-top-right-radius: 18px;
            border-bottom-left-radius: 18px;
            border-bottom-right-radius: 4px; 
        }
        
        /* Forme delle bolle iMessage (Mittente) -> Griga a Sinistra */
        #chat-window-2 .message.sender-inverted {
            align-self: flex-start;
            background-color: #e5e5ea;
            color: #000000;
            border-top-left-radius: 18px;
            border-top-right-radius: 18px;
            border-bottom-right-radius: 18px;
            border-bottom-left-radius: 4px; 
        }


        /* Indicatore "Sta scrivendo..." */
        .typing-indicator {
            display: none; 
            background-color: #e5e5ea; 
            color: #000000;
            
            padding: 12px 18px 12px 18px; 
            
            border-top-left-radius: 18px;
            border-top-right-radius: 18px;
            border-bottom-right-radius: 18px;
            border-bottom-left-radius: 4px; 
            
            width: auto; 
            height: auto; 
            
            display: flex; 
            align-items: center;
            justify-content: center; 
            box-sizing: content-box; 
            position: relative;
        }

        /* Allineamento indicatore per Chat 1 (Destinatario = Sinistra) */
        #typing-indicator-1 {
             align-self: flex-start;
        }

        /* Allineamento indicatore per Chat 2 (Destinatario INVERTITO = Destra) */
        #typing-indicator-2 {
             align-self: flex-end;
             border-top-left-radius: 18px;
             border-top-right-radius: 18px;
             border-bottom-left-radius: 18px;
             border-bottom-right-radius: 4px; 
             border-bottom-left-radius: 18px; 
        }


        /* Animazione puntini iOS */
        @keyframes ios-dot-fade {
            0%, 80%, 100% { opacity: 0.3; } 
            40% { opacity: 1; } 
        }

        .dots span {
            display: inline-block;
            width: 10px; 
            height: 10px; 
            background-color: #b0b0b0; 
            border-radius: 50%;
            margin: 0 3px; 
            animation: ios-dot-fade 1.5s infinite ease-in-out; 
        }

        .dots span:nth-child(1) { animation-delay: 0s; }
        .dots span:nth-child(2) { animation-delay: 0.2s; } 
        .dots span:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes pop-in {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }

        /* Barra di input finta */
        .fake-input-bar {
            padding: 10px 15px;
            border-top: none; /* Rimosso il bordo superiore */
            background-color: #ffffff; 
            padding-bottom: 25px; 
        }

        /* Contenitore della barra di testo */
        .fake-input-box {
            border: none;
            background-color: #f0f2f5; 
            border-radius: 20px;
            height: 40px;
            display: flex;
            align-items: center;
            padding-left: 15px;
            font-size: 1rem;
            position: relative; 
            overflow: hidden; 
        }

        /* Elemento testuale normale "Messaggio" */
        .input-typing-text {
            color: #8e8e93; 
            display: block;
            white-space: nowrap; 
        }

        /* Testo digitato dal Mittente (Contenitore + Cursore) */
        .input-message-typing-container {
            display: none;
            position: relative;
            height: 100%;
            display: flex;
            align-items: center;
            padding-right: 2px; 
        }
        
        .input-message-typing {
            color: #000000; 
            white-space: nowrap;
            overflow: hidden;
            font-size: 1rem;
        }

        /* Animazione Cursore */
        .caret {
            width: 2px;
            height: 70%;
            background-color: #007aff; 
            margin-left: 1px;
            animation: blink-caret 0.8s infinite;
        }

        @keyframes blink-caret {
            from, to { opacity: 0; }
            50% { opacity: 1; }
        }

        /* RESPONSIVITÀ COMPLETA: Schermi stretti (es. Smartphone) */
        @media (max-width: 800px) {
            #main-container {
                flex-direction: column; 
                height: auto;
                min-height: 100vh;
                padding: 10px;
                gap: 20px;
                overflow-y: auto; 
                max-width: 100%; 
            }

            .chat-container {
                width: 100%;
                max-width: 100%; 
                height: 50vh; 
            }
        }
    </style>
</head>
<body>

    <div id="main-container">
        <div id="chat-container-1" class="chat-container">
            <div id="chat-window-1" class="chat-window">
                <div id="typing-indicator-1" class="typing-indicator dots">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
            <div class="fake-input-bar">
                <div class="fake-input-box">
                    <span id="input-typing-text-1" class="input-typing-text">Messaggio</span>
                    <div id="input-message-typing-container-1" class="input-message-typing-container">
                        <span id="input-message-typing-1" class="input-message-typing"></span>
                        <span class="caret"></span>
                    </div>
                </div>
            </div>
        </div>

        <div id="chat-container-2" class="chat-container">
            <div id="chat-window-2" class="chat-window">
                <div id="typing-indicator-2" class="typing-indicator dots">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
            <div class="fake-input-bar">
                <div class="fake-input-box">
                    <span id="input-typing-text-2" class="input-typing-text">Messaggio</span>
                    <div id="input-message-typing-container-2" class="input-message-typing-container">
                        <span id="input-message-typing-2" class="input-message-typing"></span>
                        <span class="caret"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <audio id="typing-audio" loop>
        <source src="typing_sound.mp3" type="audio/mpeg">
    </audio>
    <audio id="receive-audio">
        <source src="message_received.mp3" type="audio/mpeg">
    </audio>


    <script>
        document.addEventListener("DOMContentLoaded", function() {

            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
            const typingAudio = document.getElementById('typing-audio');
            const receiveAudio = document.getElementById('receive-audio');

            let chat1Finished = false;
            let chat2Finished = false;

            let previousScript1 = null;
            let previousScript2 = null;
            let chat1, chat2;

            // =================================================================
            // === MESSAGGI BASE E GENERAZIONE RANDOMICA ===
            // =================================================================
            
            // Liste dei messaggi (dall'utente)
            const senderMessages = [
                'Sì, scusa.', 'Dimmi', 'AHAHAHAHAHAH', 'Non mi stressare', 'Sto arrivando', 
                'A che ora ci vediamo stasera?', 'Tutto bene?', 'Va bene', 'È quello che ti meriti.', 
                'Sei riuscito a prenderlo?', 'Are we gonna fuck again?', 'Sei partito?', 'Ti accompagna?', 
                'Dove sei?', 'Non ti preoccupare.', 'Ma che vuoi?', 'Va bene riso con pollo?', 
                'Tu hai le chiavi?', 'Ok', 'Dai torna.', 'Come vuoi', 'Lasciamo perdere', 'Ti amoooooooo', 
                'Amore mio', 'wanted to ask whether u know a cute bar', 'yes...', 'Vieni al ristorante', 
                'Sto prendendo la macchina. 10 minuti', 'Cosa stai facendo?', 'Ma che vuole questa?', 
                'La conosci?', 'Lo conosci?', 'how are u?', 'È tardi dove sei', 'Ma cosa ti aspettavi scusa?', 
                'Non è vero.', 'qt what are up to?', 'Sono qui sotto, apri', 'Posso venire anche stasera?', 
                'Ti serve qualcosa?', 'Sei con i tuoi amici?', 'Possiamo parlare?', 'Puoi andare tu al supermercato?', 
                'Li hai i soldi?', 'funny', 'ok thx', 'Grazie davvero per ieri', 'Risolto', 'Ti invio paypal', 
                'Eh', 'Salutami mamma e papà', 'Pizza?', 'Bella', 'Vai dalle tue amiche.', 'Sì, la ho in borsa.', 'Ti odio.'
            ];

            const fixedRecipientStart = 'Ciao, ci sei?';
            const recipientMessagesPool = [
                'Volevo solo sapere come stai', 'Perfetto, ti scrivo domani mattina', 'Quando arrivi? Ti aspetto fuori.', 
                'Hai già mangiato?', 'Mi fai sapere il prima possibile perfavore?', 'Sì, ho visto il messaggio. Grazie.', 
                'Buona idea.', 'Smettila.', 'Seriamente? Questo è tutto quello che hai dire?', 'Ti amo grazie', 
                'Non ti sopporto', 'Se non ci fossi tu...', 'Ma si può sapere che vuoi?', 'Cazzo sono in trip', 
                'Sono uscito ora.', 'Ascolta questa hit', 'Non ce la faccio più', 'Amore ci sei?', 
                'Cosa facciamo stasera?', 'Hai visto il video?', 'Mi sta antipatico', 'Ti sei già rifidanzata?', 
                'Okok', 'Brava. Sono fiero di te.', 'What do u mean?', 'Nah, ure safe.', 'idk honestly', 
                'fine thx how abt u?', 'We had great sex.', 'Queste zanzare mi stanno uccidendo.', 
                'Sto pensando a una cosa', 'Ho finito i soldi. Mi fai una ricarica?', 'Mi servono 10 euro perfavore.', 
                'Dai ti prego', 'Amo ma perchè non mi scrivi?', 'Mi manchi un sacco.', 'Sei sicura?', 'Fai tu.', 
                'ahahahah', 'Sì, questo lo so. Non sono mica stupido.', 'Ma sei ossessionata?', 
                'Non riesci ad andare avanti?', 'Mollami.', 'Stiamo prendendo due strade diverse.', 
                'Hai visto che è successo? Cosa hanno detto gli altri?', 'Sono diverso.', 
                'Sono cambiato, questa volta per davvero.', 'Ho sempre avuto ragione.', 'Sei sempre stata così.', 
                'È già pronto?', 'Perchè devi fare così?', 'Ti dimentichi sempre quello che ti conviene dimenticare.', 
                'Ho sbagliato.', 'Ti conviene fare così?', 'Non sono stupido.', 'Facciamo pace.'
            ];


            function shuffleArray(array) {
                const newArray = [...array];
                for (let i = newArray.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
                }
                return newArray;
            }

            // *** LOGICA DI GENERAZIONE MODIFICATA PER ALTERNANZA 1-A-1 ***
            function generateRandomScript() {
                const shuffledSender = shuffleArray(senderMessages);
                const shuffledRecipientBody = shuffleArray(recipientMessagesPool);
                
                const script = [];

                // 1. Frase iniziale fissa del destinatario
                const initialText = fixedRecipientStart;
                const initialTypingDuration = initialText.length * (Math.random() * 50 + 70); 
                script.push({ type: 'wait', delay: Math.floor(Math.random() * 1000) + 500 });
                script.push({ type: 'typing_start', sender: 'recipient', delay: Math.round(initialTypingDuration) }); 
                script.push({ type: 'message', sender: 'recipient', text: initialText, delay: Math.floor(Math.random() * 1500) + 1000 });

                // 2. Corpo della conversazione in STRETTA ALTERNANZA
                // Determina la lunghezza massima per assicurarsi che entrambi i pool vengano utilizzati
                const maxLength = Math.max(shuffledSender.length, shuffledRecipientBody.length);
                
                for (let i = 0; i < maxLength; i++) {
                    
                    // TURNO DEL MITTENTE (Sender)
                    // (Il primo turno del loop è del sender, dato che il recipient ha iniziato)
                    if (i < shuffledSender.length) { 
                        const text = shuffledSender[i]; 
                        const typingTime = text.length * (Math.random() * 50 + 50); 
                        
                        script.push({ type: 'wait', delay: Math.floor(Math.random() * 1000) + 500 });
                        script.push({ type: 'sender_text_typing_start', text: text, delay: Math.round(typingTime) });
                        script.push({ type: 'message', sender: 'sender', text: text, delay: Math.floor(Math.random() * 500) + 200 });
                    }

                    // TURNO DEL DESTINATARIO (Recipient)
                    if (i < shuffledRecipientBody.length) { 
                        const text = shuffledRecipientBody[i]; 
                        const typingDuration = text.length * (Math.random() * 50 + 70);
                        
                        script.push({ type: 'wait', delay: Math.floor(Math.random() * 1500) + 500 });
                        script.push({ type: 'typing_start', sender: 'recipient', delay: Math.round(typingDuration) }); 
                        script.push({ type: 'message', sender: 'recipient', text: text, delay: Math.floor(Math.random() * 1000) + 500 });
                    }
                }
                
                return script;
            }


            // Funzione per generare e garantire l'unicità degli script
            function generateUniqueScripts() {
                let script1;
                let script2;
                const MAX_ATTEMPTS = 10; 

                let attempt1 = 0;
                do {
                    script1 = generateRandomScript();
                    attempt1++;
                } while (JSON.stringify(script1) === JSON.stringify(previousScript1) && attempt1 < MAX_ATTEMPTS);


                let attempt2 = 0;
                do {
                    script2 = generateRandomScript();
                    attempt2++;
                } while (
                    (JSON.stringify(script2) === JSON.stringify(previousScript2)) || 
                    (JSON.stringify(script2) === JSON.stringify(script1)) && 
                    attempt2 < MAX_ATTEMPTS
                );

                // Aggiorna la storia
                previousScript1 = script1;
                previousScript2 = script2;

                return { script1, script2 };
            }

            // =================================================================
            // === LOGICA PER UNA SINGOLA CHAT (ADATTATA PER RUOLI INVERTITI) ===
            // =================================================================

            class ChatController {
                constructor(id, script) {
                    this.chatWindow = document.getElementById(`chat-window-${id}`);
                    this.typingIndicator = document.getElementById(`typing-indicator-${id}`); 
                    this.inputTypingText = document.getElementById(`input-typing-text-${id}`); 
                    this.inputMessageTypingContainer = document.getElementById(`input-message-typing-container-${id}`);
                    this.inputMessageTyping = document.getElementById(`input-message-typing-${id}`); 
                    this.script = script;
                    this.id = id;
                    
                    // Definisce le classi CSS appropriate
                    this.recipientClass = id === 1 ? 'recipient-default' : 'recipient-inverted';
                    this.senderClass = id === 1 ? 'sender-default' : 'sender-inverted';
                }

                addMessage(text, type) {
                    const messageElement = document.createElement('div');
                    
                    const senderClass = type === 'sender' ? this.senderClass : this.recipientClass;
                    
                    messageElement.classList.add('message', senderClass);
                    messageElement.textContent = text;
                    this.chatWindow.insertBefore(messageElement, this.typingIndicator);
                    
                    if (type === 'recipient') {
                        // Tenta la riproduzione. Se fallisce per restrizioni, il browser ignora.
                        receiveAudio.play().catch(e => {}); 
                    }
                }

                showTyping() { 
                    this.typingIndicator.style.display = 'flex'; 
                }
                hideTyping() { 
                    this.typingIndicator.style.display = 'none'; 
                }

                async typeSenderMessage(text, duration) {
                    this.inputTypingText.style.display = 'none';
                    this.inputMessageTypingContainer.style.display = 'flex'; 
                    this.inputMessageTyping.textContent = ''; 
                    
                    if (typingAudio.paused) {
                        // Tenta la riproduzione. Se fallisce per restrizioni, il browser ignora.
                        typingAudio.play().catch(e => {}); 
                    }
                    
                    const charDelay = duration / text.length; 
                    
                    for (let i = 0; i < text.length; i++) {
                        this.inputMessageTyping.textContent += text.charAt(i);
                        await sleep(charDelay);
                    }
                    
                    typingAudio.pause();
                    typingAudio.currentTime = 0; 
                }

                resetInputBar() {
                    this.inputTypingText.style.display = 'block';
                    this.inputMessageTypingContainer.style.display = 'none';
                    this.inputMessageTyping.textContent = '';
                    
                    typingAudio.pause();
                    typingAudio.currentTime = 0;
                }

                async runScript() {
                    this.hideTyping();
                    this.resetInputBar();

                    for (const step of this.script) {
                        
                        if (step.type === 'wait') {
                           await sleep(step.delay);
                        } else if (step.type === 'message') {
                            // Questo messaggio attende il tempo definito in .delay
                            await sleep(step.delay); 
                            
                            this.hideTyping();
                            this.resetInputBar(); 
                            this.addMessage(step.text, step.sender); 
                        } else if (step.type === 'typing_start' && step.sender === 'recipient') { 
                            // Avvia la simulazione "Sta scrivendo..." per il Recipient
                            this.showTyping();
                            await sleep(step.delay); // Attende il tempo proporzionale
                        } else if (step.type === 'sender_text_typing_start') { 
                            // Avvia la digitazione nella barra di input per il Sender
                            // (Rimosso 'await sleep(step.delay);' da qui, perché la durata è già gestita da typeSenderMessage)
                            await this.typeSenderMessage(step.text, step.delay);
                        }
                    }

                    if (this.id === 1) {
                        chat1Finished = true;
                    } else {
                        chat2Finished = true;
                    }

                    if (chat1Finished && chat2Finished) {
                        await startNewIteration();
                    }
                }
            }

            // =================================================================
            // === LOGICA DI AVVIO E RIPETIZIONE SINCRONIZZATA ===
            // =================================================================

            async function generateAndStartChats() {
                const { script1, script2 } = generateUniqueScripts();

                if (!chat1) {
                    chat1 = new ChatController(1, script1);
                    chat2 = new ChatController(2, script2);
                } else {
                    chat1.script = script1;
                    chat2.script = script2;
                }

                chat1Finished = false;
                chat2Finished = false;

                // Avvia le chat con un piccolo sfasamento temporale casuale
                chat1.runScript();
                sleep(Math.random() * 1000).then(() => chat2.runScript());
            }

            async function startNewIteration() {
                // *** MODIFICA CHIAVE: PAUSA DI 10 SECONDI ***
                await sleep(10000); 

                chat1.chatWindow.querySelectorAll('.message').forEach(msg => msg.remove());
                chat2.chatWindow.querySelectorAll('.message').forEach(msg => msg.remove());
                
                chat1.hideTyping();
                chat1.resetInputBar();
                chat2.hideTyping();
                chat2.resetInputBar();

                await sleep(500);
                
                await generateAndStartChats();
            }

            // AVVIO IMMEDIATO
            generateAndStartChats();

        });
    </script>

</body>
</html>
